<head>
  <title>Treemap</title>
  <script src="//unpkg.com/treemap-chart"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>
  <link
    rel="stylesheet"
    href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"
  />
  <style type="text/css">
    main {
      padding: 1rem !important;
    }
    #charts {
      width: 100%;
      display: flex;
      gap: 1rem;
      justify-content: space-between;
    }
    .treemap-viz rect {
      stroke: none !important;
    }
    .chart-tooltip {
      font-family: monospace !important;
    }
  </style>
</head>
<body>
  <main>
    <div id="search">
      <input type="text" placeholder="Search for an address" />
    </div>
    <div id="charts">
      <div id="chart-0"></div>
      <div id="chart-1"></div>
      <div id="chart-2"></div>
    </div>
  </main>
  <script>
    const main = async () => {
      const accountsResp = await fetch('./Genesis/accounts.json')
      let accounts = await accountsResp.json()

      const fmt = (n) => numeral(n).format('0.[00]a')

      // $500m FDV
      const hypotheticalAuraPrice = 5

      const balPrice = 15.77
      const cvxPrice = 35.81

      accounts = Object.fromEntries(
        Object.entries(accounts).map(
          ([address, { rescaledAllocation, rawBalances, ...account }]) => [
            address,
            {
              ...account,
              rawBalances: Object.fromEntries(
                Object.entries(rawBalances).map(([key, value]) => [
                  key,
                  parseInt(value) / 1e18,
                ]),
              ),
              rescaledAllocation: Object.fromEntries(
                Object.entries(rescaledAllocation).map(([key, value]) => [
                  key,
                  parseInt(value) / 1e18,
                ]),
              ),
            },
          ],
        ),
      )

      const voteEntries = Object.entries(accounts).filter(
        ([, { vote }]) => vote === 'Y',
      )
      const vlCvxEntries = Object.entries(accounts).filter(
        ([
          ,
          {
            rescaledAllocation: { vlCVX },
          },
        ]) => vlCVX > 0,
      )
      const balEntries = Object.entries(accounts).filter(
        ([
          ,
          {
            rescaledAllocation: { BAL },
          },
        ]) => BAL > 0,
      )

      const data = {
        name: 'root',
        children: [
          {
            name: 'Vote',
            color: 'transparent',
            tooltipContent: `${voteEntries.length} accounts (${fmt(
              voteEntries.reduce(
                (
                  prev,
                  [
                    ,
                    {
                      rawBalances: { votingPower },
                    },
                  ],
                ) => prev + votingPower,
                0,
              ),
            )} voting power)`,
            children: voteEntries.map(
              ([address, { rawBalances, rescaledAllocation }], index) => ({
                name: address,
                address,
                value: rescaledAllocation.votingPower,
                color: index % 2 === 0 ? '#59a619' : '#91c765',
                tooltipContent: (() => {
                  const airdropValue =
                    rescaledAllocation.votingPower * hypotheticalAuraPrice
                  const holdingValue = rawBalances.votingPower * balPrice
                  const rewardPerToken =
                    rescaledAllocation.votingPower / rawBalances.votingPower
                  const pricePerReward =
                    (rawBalances.votingPower * balPrice) /
                    (rescaledAllocation.votingPower * hypotheticalAuraPrice)
                  const costBasis = pricePerReward.toFixed(2)
                  return `
                    <div>AURA: ${fmt(rescaledAllocation.votingPower)} ($${fmt(
                    airdropValue,
                  )})</div>
                    <div>Votes: ${fmt(rawBalances.votingPower)} ($${fmt(
                    holdingValue,
                  )})</div>
                    <div>AURA per votes: ${rewardPerToken.toFixed(4)}</div>
                    <div>Cost basis: $${costBasis}</div>
                    `
                })(),
              }),
            ),
          },
          {
            name: 'vlCVX',
            tooltipContent: `${vlCvxEntries.length} accounts (${fmt(
              vlCvxEntries.reduce(
                (
                  prev,
                  [
                    ,
                    {
                      rawBalances: { vlCVX },
                    },
                  ],
                ) => prev + vlCVX,
                0,
              ),
            )} vlCVX)`,
            color: 'transparent',
            children: vlCvxEntries.map(
              ([address, { rawBalances, rescaledAllocation }], index) => ({
                name: address,
                address,
                value: rescaledAllocation.vlCVX,
                color: index % 2 === 0 ? '#ffa200' : '#fdbe49',
                tooltipContent: (() => {
                  const airdropValue =
                    rescaledAllocation.vlCVX * hypotheticalAuraPrice
                  const holdingValue = rawBalances.vlCVX * cvxPrice
                  const rewardPerToken =
                    rescaledAllocation.vlCVX / rawBalances.vlCVX
                  const pricePerReward =
                    (rawBalances.vlCVX * cvxPrice) /
                    (rescaledAllocation.vlCVX * hypotheticalAuraPrice)
                  const costBasis = pricePerReward.toFixed(2)
                  return `
                    <div>AURA: ${fmt(rescaledAllocation.vlCVX)} ($${fmt(
                    airdropValue,
                  )})</div>
                    <div>vlCVX: ${fmt(rawBalances.vlCVX)}  ($${fmt(
                    holdingValue,
                  )})</div>
                    <div>AURA per vlCVX: ${rewardPerToken.toFixed(4)}</div>
                    <div>Cost basis: $${costBasis}</div>
                    `
                })(),
              }),
            ),
          },
          {
            name: 'BAL',
            color: 'transparent',
            tooltipContent: `${balEntries.length} accounts (${fmt(
              balEntries.reduce(
                (
                  prev,
                  [
                    ,
                    {
                      rawBalances: { BAL },
                    },
                  ],
                ) => prev + BAL,
                0,
              ),
            )} BAL)`,
            children: balEntries.sort((a, b) => b[1].rescaledAllocation.BAL - a[1].rescaledAllocation.BAL).map(
              ([address, { rawBalances, rescaledAllocation }], index) => ({
                name: address,
                address,
                value: rescaledAllocation.BAL,
                color: index % 2 === 0 ? '#053a77' : '#1e559d',
                tooltipContent: (() => {
                  const airdropValue =
                    rescaledAllocation.BAL * hypotheticalAuraPrice
                  const holdingValue = rawBalances.BAL * balPrice
                  const rewardPerToken =
                    rescaledAllocation.BAL / rawBalances.BAL
                  const pricePerReward =
                    (rawBalances.BAL * balPrice) /
                    (rescaledAllocation.BAL * hypotheticalAuraPrice)
                  const costBasis = pricePerReward.toFixed(2)
                  return `
                    <div>AURA: ${fmt(rescaledAllocation.BAL)} ($${fmt(
                    airdropValue,
                  )})</div>
                    <div>BAL: ${fmt(rawBalances.BAL)} ($${fmt(
                    holdingValue,
                  )})</div>
                    <div>AURA per BAL: ${rewardPerToken.toFixed(4)}</div>
                    <div>Cost basis: $${costBasis}</div>
                    `
                })(),
              }),
            ),
          },
        ],
      }

      const charts = data.children.map((group) =>
        Treemap()
          .data(group)
          .excludeRoot(true)
          .tooltipContent((node) => {
            return node.tooltipContent || ''
          })
          .width(window.innerWidth * 0.31)
          .height(window.innerHeight - 210)
          .padding(0)
          .color('color')
          .transitionDuration(0)
          .showLabels(false)
          .minBlockArea(0)
          .onClick((node) => {
            if (node.address) {
              window.open(`https://etherscan.io/address/${node.address}`)
            }
          }),
      )

      charts.forEach((chart, idx) =>
        chart(document.getElementById(`chart-${idx}`)),
      )

      const searchInput = document.querySelector('#search > input')

      searchInput.addEventListener('paste', () => {
        searchInput.onchange()
      })

      searchInput.addEventListener('change', (event) => {
        const input = event.target.value
        if (input.startsWith('0x')) {
          const address = input.toLowerCase()
          const account = accounts[address]
          if (account) {
            charts.forEach((chart) => {
              const node = chart
                .data()
                .children.filter((node) => node.address === address)[0]
              if (node) {
                chart.zoomToNode(node).zoomBy(0.75)
              } else {
                chart.zoomReset()
              }
            })
          }
        } else {
          charts.forEach((chart) => {
            chart.zoomReset()
          })
        }
      })
    }
    main()
  </script>
</body>
