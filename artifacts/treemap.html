<head>
  <title>Treemap</title>
  <script src="//unpkg.com/treemap-chart"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>
  <link
    rel="stylesheet"
    href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"
  />
  <style>
    main {
      padding: 1rem !important;
    }

    #charts {
      width: 100%;
      display: flex;
      gap: 1rem;
      justify-content: space-between;
    }

    .treemap-viz rect {
      stroke: none !important;
    }

    .chart-tooltip {
      font-family: monospace !important;
    }
  </style>
</head>
<body>
  <main>
    <div id="search">
      <input type="text" placeholder="Search for an address" />
    </div>
    <div id="charts">
      <div id="chart-0"></div>
      <div id="chart-1"></div>
    </div>
  </main>
  <script>
    const main = async () => {
      const fmt = (n) => numeral(n).format('0.[00]a')

      // $500m FDV
      const hypotheticalAuraPrice = 5

      const balPrice = 15.77
      const cvxPrice = 35.81

      const convexAccountsResp = await fetch('./convex/convex.json')
      const balancerAccountsResp = await fetch('./balancer/balancer.json')
      let convexAccounts = await convexAccountsResp.json()
      let balancerAccounts = await balancerAccountsResp.json()

      convexAccounts = Object.fromEntries(
        Object.entries(convexAccounts).map(
          ([address, { allocation, vlCVX }]) => [
            address,
            {
              balance: parseInt(vlCVX) / 1e18,
              allocation: parseInt(allocation.convex) / 1e18,
            },
          ],
        ),
      )
      balancerAccounts = Object.fromEntries(
        Object.entries(balancerAccounts).map(
          ([address, { allocation, BAL, vote }]) => [
            address,
            {
              balance: parseInt(BAL) / 1e18,
              allocation: parseInt(allocation.balancer) / 1e18,
              vote,
            },
          ],
        ),
      )

      const convexEntries = Object.entries(convexAccounts).filter(
        ([, { allocation }]) => allocation > 0,
      )
      const balancerEntries = Object.entries(balancerAccounts).filter(
        ([, { allocation }]) => allocation > 0,
      )

      const data = {
        name: 'root',
        children: [
          {
            name: 'convex',
            tooltipContent: `${convexEntries.length} accounts (${fmt(
              convexEntries.reduce(
                (prev, [, { balance }]) => prev + balance,
                0,
              ),
            )} vlCVX)`,
            color: 'transparent',
            children: convexEntries.map(
              ([address, { balance, allocation }], index) => ({
                name: address,
                address,
                value: allocation,
                color: index % 2 === 0 ? '#ffa200' : '#fdbe49',
                tooltipContent: (() => {
                  const airdropValue = allocation * hypotheticalAuraPrice
                  const holdingValue = balance * cvxPrice
                  const rewardPerToken = allocation / balance
                  const pricePerReward =
                    (balance * cvxPrice) / (allocation * hypotheticalAuraPrice)
                  const costBasis = pricePerReward.toFixed(2)
                  return `
                    <div>AURA: ${fmt(allocation)} ($${fmt(airdropValue)})</div>
                    <div>vlCVX: ${fmt(balance)}  ($${fmt(holdingValue)})</div>
                    <div>AURA per vlCVX: ${rewardPerToken.toFixed(4)}</div>
                    <div>Cost basis: $${costBasis}</div>
                    `
                })(),
              }),
            ),
          },
          {
            name: 'balancer',
            color: 'transparent',
            tooltipContent: `${balancerEntries.length} accounts (${fmt(
              balancerEntries.reduce(
                (prev, [, { balance }]) => prev + balance,
                0,
              ),
            )} BAL)`,
            children: balancerEntries
              .sort((a, b) => b[1].allocation - a[1].allocation)
              .map(([address, { balance, allocation, vote }], index) => ({
                name: address,
                address,
                value: allocation,
                color: vote === 'Y' ? '#02e1ff' : vote === 'N' ? '#f53a77' : index % 2 === 0 ? '#053a77' : '#1e559d',
                tooltipContent: (() => {
                  const airdropValue = allocation * hypotheticalAuraPrice
                  const holdingValue = balance * balPrice
                  const rewardPerToken = allocation / balance
                  const pricePerReward =
                    (balance * balPrice) / (allocation * hypotheticalAuraPrice)
                  const costBasis = pricePerReward.toFixed(2)
                  return `
                    <div>AURA: ${fmt(allocation)} ($${fmt(airdropValue)})</div>
                    <div>BAL: ${fmt(balance)} ($${fmt(
                    holdingValue,
                  )})</div><div>Vote: ${vote}</div>
                    <div>AURA per BAL: ${rewardPerToken.toFixed(4)}</div>
                    <div>Cost basis: $${costBasis}</div>
                    `
                })(),
              })),
          },
        ],
      }

      const charts = data.children.map((group) =>
        Treemap()
          .data(group)
          .excludeRoot(true)
          .tooltipContent((node) => {
            return node.tooltipContent || ''
          })
          .width(window.innerWidth * 0.49)
          .height(window.innerHeight - 210)
          .padding(0)
          .color('color')
          .transitionDuration(0)
          .showLabels(false)
          .minBlockArea(0)
          .onClick((node) => {
            if (node.address) {
              window.open(`https://etherscan.io/address/${node.address}`)
            }
          }),
      )

      charts.forEach((chart, idx) =>
        chart(document.getElementById(`chart-${idx}`)),
      )

      const searchInput = document.querySelector('#search > input')

      searchInput.addEventListener('paste', () => {
        searchInput.onchange()
      })

      searchInput.addEventListener('change', (event) => {
        const input = event.target.value
        if (input.startsWith('0x')) {
          const address = input.toLowerCase()
          const account = balancerAccounts[address] ?? convexAccounts[address]
          if (account) {
            charts.forEach((chart) => {
              const node = chart
                .data()
                .children.filter((node) => node.address === address)[0]
              if (node) {
                chart.zoomToNode(node).zoomBy(0.75)
              } else {
                chart.zoomReset()
              }
            })
          }
        } else {
          charts.forEach((chart) => {
            chart.zoomReset()
          })
        }
      })
    }
    main()
  </script>
</body>
